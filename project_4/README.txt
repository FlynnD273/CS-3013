We started off with the skeleton code for the map, store, and load methods. We didn't bother with user input in the beginning, since it was more useful to get the memory methods working before doing anything else. So in the maub nethod we just called the memory methods manually at first. We originally made it so that each page table entry was stored in 3 bytes. One for the VPM, one for the frame number, and one for the permission bit, just so it was fewer things to debug. Once we got all three methods working, we switched to using a single byte to store all three values using bitshifts and bitmasks. After that was working, we then made it so that it would attempt to map more memory on an invalid store call.
For swapping, we started by implementing disk as a second array similar to memory to make sure we could get the logic before moving on to file IO. We then came up with an algorithm such that any given virtual page would always be stored in the same location on disk, and implemented a method to move a page with a known PID, vpn, and frame number to the disk in it's particular position. We then setup a method to evict a page table, and made sure it took all of its pages with it, so that any page stored in memory would always belong to a page table also in memory.	Once that was in place, we set up a method to remove an arbitrary page, which now had to fall into one of three categories: Page table, associated page, or abandoned page. With our existing methods, all 3 of these were easy to evict - the one wrinkle being to find the page table for an associated page, and update its table entry.
Once our eviction methods were complete and we could guarantee available space, we moved on to loading from disk. Since pages were stored in consistent locations on disk, if we knew what we wanted to load, it would be easy to load them in. To handle this, we had separate methods to load data pages and page tables, with the primary difference being that page tables updated our table_loc array, and data pages updated their respective page tables.
Additionally, we wrote a few example inputs to test the program and ensure that the behaviour we expect is the behaviour we get.
